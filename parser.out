Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> programa_aux var procedure block END
Rule 2     programa_aux -> PROGRAM
Rule 3     var -> DIM repeated_identifier AS type repeated_size aux_size var
Rule 4     var -> DIM repeated_identifier AS STRING_TYPE var
Rule 5     var -> empty
Rule 6     repeated_size -> LBRACKET INT RBRACKET repeated_size
Rule 7     repeated_size -> empty
Rule 8     aux_size -> empty
Rule 9     repeated_identifier -> IDENTIFIER COMMA repeated_identifier
Rule 10    repeated_identifier -> IDENTIFIER
Rule 11    type -> INT_TYPE
Rule 12    type -> FLOAT_TYPE
Rule 13    block -> statement block
Rule 14    block -> empty
Rule 15    statement -> GOTO LABEL
Rule 16    statement -> LABEL_SALTO
Rule 17    statement -> FOR aux1 TO aux2 block NEXT aux3
Rule 18    aux1 -> IDENTIFIER EQUALS expression
Rule 19    aux2 -> expression
Rule 20    aux3 -> IDENTIFIER
Rule 21    statement -> DO do_while_inicio block LOOP WHILE aux_do_while
Rule 22    do_while_inicio -> empty
Rule 23    aux_do_while -> expression
Rule 24    statement -> WHILE aux_while DO block LOOP fin_while
Rule 25    aux_while -> expression
Rule 26    fin_while -> empty
Rule 27    statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin
Rule 28    aux_if -> expression
Rule 29    aux_else -> empty
Rule 30    aux_fin -> empty
Rule 31    statement -> LET aux_array EQUALS expression
Rule 32    statement -> CALL LABEL
Rule 33    procedure -> aux_label block aux_return procedure
Rule 34    procedure -> empty
Rule 35    aux_label -> LABEL
Rule 36    aux_return -> RETURN
Rule 37    statement -> INPUT repeated_print
Rule 38    statement -> PRINT repeated_print
Rule 39    repeated_print -> repeated_elem COMMA repeated_print
Rule 40    repeated_print -> repeated_elem
Rule 41    repeated_elem -> STRING
Rule 42    repeated_elem -> elem
Rule 43    expression -> expression_s op_rel expression_s
Rule 44    expression -> expression_s
Rule 45    expression_s -> term
Rule 46    expression_s -> term PLUS expression_s
Rule 47    expression_s -> term MINUS expression_s
Rule 48    expression_s -> term OR expression_s
Rule 49    term -> factor
Rule 50    term -> factor MULTIPLY term
Rule 51    term -> factor DIVIDE term
Rule 52    term -> factor AND term
Rule 53    factor -> elem
Rule 54    factor -> OPENPAR expression CLOSEPAR
Rule 55    elem -> INT
Rule 56    elem -> aux_array
Rule 57    elem -> elem_else
Rule 58    aux_array -> size_identifier repeated_size_access end_array
Rule 59    size_identifier -> IDENTIFIER
Rule 60    repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access
Rule 61    repeated_size_access -> empty
Rule 62    end_array -> empty
Rule 63    elem_else -> FLOAT
Rule 64    op_rel -> LESSTHANOREQUAL
Rule 65    op_rel -> GREATERTHANOREQUAL
Rule 66    op_rel -> ISEQUALTO
Rule 67    op_rel -> GREATERTHAN
Rule 68    op_rel -> LESSTHAN
Rule 69    empty -> <empty>

Terminals, with rules where they appear

AND                  : 52
AS                   : 3 4
CALL                 : 32
CLOSEPAR             : 54
COMMA                : 9 39
DIM                  : 3 4
DIVIDE               : 51
DO                   : 21 24
ELSE                 : 27
END                  : 1 27
EQUALS               : 18 31
FLOAT                : 63
FLOAT_TYPE           : 12
FOR                  : 17
GOTO                 : 15
GREATERTHAN          : 67
GREATERTHANOREQUAL   : 65
IDENTIFIER           : 9 10 18 20 59
IF                   : 27 27
INPUT                : 37
INT                  : 6 55
INT_TYPE             : 11
ISEQUALTO            : 66
LABEL                : 15 32 35
LABEL_SALTO          : 16
LBRACKET             : 6 60
LESSTHAN             : 68
LESSTHANOREQUAL      : 64
LET                  : 31
LOOP                 : 21 24
MINUS                : 47
MULTIPLY             : 50
NEXT                 : 17
OPENPAR              : 54
OR                   : 48
PLUS                 : 46
PRINT                : 38
PROGRAM              : 2
RBRACKET             : 6 60
RETURN               : 36
STRING               : 41
STRING_TYPE          : 4
THEN                 : 27
TO                   : 17
WHILE                : 21 24
error                : 

Nonterminals, with rules where they appear

aux1                 : 17
aux2                 : 17
aux3                 : 17
aux_array            : 31 56
aux_do_while         : 21
aux_else             : 27
aux_fin              : 27
aux_if               : 27
aux_label            : 33
aux_return           : 33
aux_size             : 3
aux_while            : 24
block                : 1 13 17 21 24 27 27 33
do_while_inicio      : 21
elem                 : 42 53
elem_else            : 57
empty                : 5 7 8 14 22 26 29 30 34 61 62
end_array            : 58
expression           : 18 19 23 25 28 31 54 60
expression_s         : 43 43 44 46 47 48
factor               : 49 50 51 52
fin_while            : 24
op_rel               : 43
procedure            : 1 33
programa             : 0
programa_aux         : 1
repeated_elem        : 39 40
repeated_identifier  : 3 4 9
repeated_print       : 37 38 39
repeated_size        : 3 6
repeated_size_access : 58 60
size_identifier      : 58
statement            : 13
term                 : 45 46 47 48 50 51 52
type                 : 3
var                  : 1 3 4

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . programa_aux var procedure block END
    (2) programa_aux -> . PROGRAM

    PROGRAM         shift and go to state 3

    programa                       shift and go to state 1
    programa_aux                   shift and go to state 2

state 1

    (0) S' -> programa .



state 2

    (1) programa -> programa_aux . var procedure block END
    (3) var -> . DIM repeated_identifier AS type repeated_size aux_size var
    (4) var -> . DIM repeated_identifier AS STRING_TYPE var
    (5) var -> . empty
    (69) empty -> .

    DIM             shift and go to state 5
    LABEL           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    var                            shift and go to state 4
    empty                          shift and go to state 6

state 3

    (2) programa_aux -> PROGRAM .

    DIM             reduce using rule 2 (programa_aux -> PROGRAM .)
    LABEL           reduce using rule 2 (programa_aux -> PROGRAM .)
    GOTO            reduce using rule 2 (programa_aux -> PROGRAM .)
    LABEL_SALTO     reduce using rule 2 (programa_aux -> PROGRAM .)
    FOR             reduce using rule 2 (programa_aux -> PROGRAM .)
    DO              reduce using rule 2 (programa_aux -> PROGRAM .)
    WHILE           reduce using rule 2 (programa_aux -> PROGRAM .)
    IF              reduce using rule 2 (programa_aux -> PROGRAM .)
    LET             reduce using rule 2 (programa_aux -> PROGRAM .)
    CALL            reduce using rule 2 (programa_aux -> PROGRAM .)
    INPUT           reduce using rule 2 (programa_aux -> PROGRAM .)
    PRINT           reduce using rule 2 (programa_aux -> PROGRAM .)
    END             reduce using rule 2 (programa_aux -> PROGRAM .)


state 4

    (1) programa -> programa_aux var . procedure block END
    (33) procedure -> . aux_label block aux_return procedure
    (34) procedure -> . empty
    (35) aux_label -> . LABEL
    (69) empty -> .

    LABEL           shift and go to state 10
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    procedure                      shift and go to state 7
    aux_label                      shift and go to state 8
    empty                          shift and go to state 9

state 5

    (3) var -> DIM . repeated_identifier AS type repeated_size aux_size var
    (4) var -> DIM . repeated_identifier AS STRING_TYPE var
    (9) repeated_identifier -> . IDENTIFIER COMMA repeated_identifier
    (10) repeated_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    repeated_identifier            shift and go to state 11

state 6

    (5) var -> empty .

    LABEL           reduce using rule 5 (var -> empty .)
    GOTO            reduce using rule 5 (var -> empty .)
    LABEL_SALTO     reduce using rule 5 (var -> empty .)
    FOR             reduce using rule 5 (var -> empty .)
    DO              reduce using rule 5 (var -> empty .)
    WHILE           reduce using rule 5 (var -> empty .)
    IF              reduce using rule 5 (var -> empty .)
    LET             reduce using rule 5 (var -> empty .)
    CALL            reduce using rule 5 (var -> empty .)
    INPUT           reduce using rule 5 (var -> empty .)
    PRINT           reduce using rule 5 (var -> empty .)
    END             reduce using rule 5 (var -> empty .)


state 7

    (1) programa -> programa_aux var procedure . block END
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    END             reduce using rule 69 (empty -> .)

    block                          shift and go to state 13
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 8

    (33) procedure -> aux_label . block aux_return procedure
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    RETURN          reduce using rule 69 (empty -> .)

    block                          shift and go to state 26
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 9

    (34) procedure -> empty .

    GOTO            reduce using rule 34 (procedure -> empty .)
    LABEL_SALTO     reduce using rule 34 (procedure -> empty .)
    FOR             reduce using rule 34 (procedure -> empty .)
    DO              reduce using rule 34 (procedure -> empty .)
    WHILE           reduce using rule 34 (procedure -> empty .)
    IF              reduce using rule 34 (procedure -> empty .)
    LET             reduce using rule 34 (procedure -> empty .)
    CALL            reduce using rule 34 (procedure -> empty .)
    INPUT           reduce using rule 34 (procedure -> empty .)
    PRINT           reduce using rule 34 (procedure -> empty .)
    END             reduce using rule 34 (procedure -> empty .)


state 10

    (35) aux_label -> LABEL .

    GOTO            reduce using rule 35 (aux_label -> LABEL .)
    LABEL_SALTO     reduce using rule 35 (aux_label -> LABEL .)
    FOR             reduce using rule 35 (aux_label -> LABEL .)
    DO              reduce using rule 35 (aux_label -> LABEL .)
    WHILE           reduce using rule 35 (aux_label -> LABEL .)
    IF              reduce using rule 35 (aux_label -> LABEL .)
    LET             reduce using rule 35 (aux_label -> LABEL .)
    CALL            reduce using rule 35 (aux_label -> LABEL .)
    INPUT           reduce using rule 35 (aux_label -> LABEL .)
    PRINT           reduce using rule 35 (aux_label -> LABEL .)
    RETURN          reduce using rule 35 (aux_label -> LABEL .)


state 11

    (3) var -> DIM repeated_identifier . AS type repeated_size aux_size var
    (4) var -> DIM repeated_identifier . AS STRING_TYPE var

    AS              shift and go to state 27


state 12

    (9) repeated_identifier -> IDENTIFIER . COMMA repeated_identifier
    (10) repeated_identifier -> IDENTIFIER .

    COMMA           shift and go to state 28
    AS              reduce using rule 10 (repeated_identifier -> IDENTIFIER .)


state 13

    (1) programa -> programa_aux var procedure block . END

    END             shift and go to state 29


state 14

    (13) block -> statement . block
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    END             reduce using rule 69 (empty -> .)
    RETURN          reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)
    ELSE            reduce using rule 69 (empty -> .)
    NEXT            reduce using rule 69 (empty -> .)

    statement                      shift and go to state 14
    block                          shift and go to state 30
    empty                          shift and go to state 15

state 15

    (14) block -> empty .

    END             reduce using rule 14 (block -> empty .)
    RETURN          reduce using rule 14 (block -> empty .)
    LOOP            reduce using rule 14 (block -> empty .)
    ELSE            reduce using rule 14 (block -> empty .)
    NEXT            reduce using rule 14 (block -> empty .)


state 16

    (15) statement -> GOTO . LABEL

    LABEL           shift and go to state 31


state 17

    (16) statement -> LABEL_SALTO .

    GOTO            reduce using rule 16 (statement -> LABEL_SALTO .)
    LABEL_SALTO     reduce using rule 16 (statement -> LABEL_SALTO .)
    FOR             reduce using rule 16 (statement -> LABEL_SALTO .)
    DO              reduce using rule 16 (statement -> LABEL_SALTO .)
    WHILE           reduce using rule 16 (statement -> LABEL_SALTO .)
    IF              reduce using rule 16 (statement -> LABEL_SALTO .)
    LET             reduce using rule 16 (statement -> LABEL_SALTO .)
    CALL            reduce using rule 16 (statement -> LABEL_SALTO .)
    INPUT           reduce using rule 16 (statement -> LABEL_SALTO .)
    PRINT           reduce using rule 16 (statement -> LABEL_SALTO .)
    END             reduce using rule 16 (statement -> LABEL_SALTO .)
    RETURN          reduce using rule 16 (statement -> LABEL_SALTO .)
    LOOP            reduce using rule 16 (statement -> LABEL_SALTO .)
    ELSE            reduce using rule 16 (statement -> LABEL_SALTO .)
    NEXT            reduce using rule 16 (statement -> LABEL_SALTO .)


state 18

    (17) statement -> FOR . aux1 TO aux2 block NEXT aux3
    (18) aux1 -> . IDENTIFIER EQUALS expression

    IDENTIFIER      shift and go to state 33

    aux1                           shift and go to state 32

state 19

    (21) statement -> DO . do_while_inicio block LOOP WHILE aux_do_while
    (22) do_while_inicio -> . empty
    (69) empty -> .

    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)

    do_while_inicio                shift and go to state 34
    empty                          shift and go to state 35

state 20

    (24) statement -> WHILE . aux_while DO block LOOP fin_while
    (25) aux_while -> . expression
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    aux_while                      shift and go to state 36
    expression                     shift and go to state 37
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 21

    (27) statement -> IF . aux_if THEN block ELSE aux_else block END IF aux_fin
    (28) aux_if -> . expression
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    aux_if                         shift and go to state 49
    expression                     shift and go to state 50
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 22

    (31) statement -> LET . aux_array EQUALS expression
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (59) size_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 48

    aux_array                      shift and go to state 51
    size_identifier                shift and go to state 46

state 23

    (32) statement -> CALL . LABEL

    LABEL           shift and go to state 52


state 24

    (37) statement -> INPUT . repeated_print
    (39) repeated_print -> . repeated_elem COMMA repeated_print
    (40) repeated_print -> . repeated_elem
    (41) repeated_elem -> . STRING
    (42) repeated_elem -> . elem
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    STRING          shift and go to state 55
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    repeated_print                 shift and go to state 53
    repeated_elem                  shift and go to state 54
    elem                           shift and go to state 56
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 25

    (38) statement -> PRINT . repeated_print
    (39) repeated_print -> . repeated_elem COMMA repeated_print
    (40) repeated_print -> . repeated_elem
    (41) repeated_elem -> . STRING
    (42) repeated_elem -> . elem
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    STRING          shift and go to state 55
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    repeated_print                 shift and go to state 57
    repeated_elem                  shift and go to state 54
    elem                           shift and go to state 56
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 26

    (33) procedure -> aux_label block . aux_return procedure
    (36) aux_return -> . RETURN

    RETURN          shift and go to state 59

    aux_return                     shift and go to state 58

state 27

    (3) var -> DIM repeated_identifier AS . type repeated_size aux_size var
    (4) var -> DIM repeated_identifier AS . STRING_TYPE var
    (11) type -> . INT_TYPE
    (12) type -> . FLOAT_TYPE

    STRING_TYPE     shift and go to state 61
    INT_TYPE        shift and go to state 62
    FLOAT_TYPE      shift and go to state 63

    type                           shift and go to state 60

state 28

    (9) repeated_identifier -> IDENTIFIER COMMA . repeated_identifier
    (9) repeated_identifier -> . IDENTIFIER COMMA repeated_identifier
    (10) repeated_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    repeated_identifier            shift and go to state 64

state 29

    (1) programa -> programa_aux var procedure block END .

    $end            reduce using rule 1 (programa -> programa_aux var procedure block END .)


state 30

    (13) block -> statement block .

    END             reduce using rule 13 (block -> statement block .)
    RETURN          reduce using rule 13 (block -> statement block .)
    LOOP            reduce using rule 13 (block -> statement block .)
    ELSE            reduce using rule 13 (block -> statement block .)
    NEXT            reduce using rule 13 (block -> statement block .)


state 31

    (15) statement -> GOTO LABEL .

    GOTO            reduce using rule 15 (statement -> GOTO LABEL .)
    LABEL_SALTO     reduce using rule 15 (statement -> GOTO LABEL .)
    FOR             reduce using rule 15 (statement -> GOTO LABEL .)
    DO              reduce using rule 15 (statement -> GOTO LABEL .)
    WHILE           reduce using rule 15 (statement -> GOTO LABEL .)
    IF              reduce using rule 15 (statement -> GOTO LABEL .)
    LET             reduce using rule 15 (statement -> GOTO LABEL .)
    CALL            reduce using rule 15 (statement -> GOTO LABEL .)
    INPUT           reduce using rule 15 (statement -> GOTO LABEL .)
    PRINT           reduce using rule 15 (statement -> GOTO LABEL .)
    END             reduce using rule 15 (statement -> GOTO LABEL .)
    RETURN          reduce using rule 15 (statement -> GOTO LABEL .)
    LOOP            reduce using rule 15 (statement -> GOTO LABEL .)
    ELSE            reduce using rule 15 (statement -> GOTO LABEL .)
    NEXT            reduce using rule 15 (statement -> GOTO LABEL .)


state 32

    (17) statement -> FOR aux1 . TO aux2 block NEXT aux3

    TO              shift and go to state 65


state 33

    (18) aux1 -> IDENTIFIER . EQUALS expression

    EQUALS          shift and go to state 66


state 34

    (21) statement -> DO do_while_inicio . block LOOP WHILE aux_do_while
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    LOOP            reduce using rule 69 (empty -> .)

    block                          shift and go to state 67
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 35

    (22) do_while_inicio -> empty .

    GOTO            reduce using rule 22 (do_while_inicio -> empty .)
    LABEL_SALTO     reduce using rule 22 (do_while_inicio -> empty .)
    FOR             reduce using rule 22 (do_while_inicio -> empty .)
    DO              reduce using rule 22 (do_while_inicio -> empty .)
    WHILE           reduce using rule 22 (do_while_inicio -> empty .)
    IF              reduce using rule 22 (do_while_inicio -> empty .)
    LET             reduce using rule 22 (do_while_inicio -> empty .)
    CALL            reduce using rule 22 (do_while_inicio -> empty .)
    INPUT           reduce using rule 22 (do_while_inicio -> empty .)
    PRINT           reduce using rule 22 (do_while_inicio -> empty .)
    LOOP            reduce using rule 22 (do_while_inicio -> empty .)


state 36

    (24) statement -> WHILE aux_while . DO block LOOP fin_while

    DO              shift and go to state 68


state 37

    (25) aux_while -> expression .

    DO              reduce using rule 25 (aux_while -> expression .)


state 38

    (43) expression -> expression_s . op_rel expression_s
    (44) expression -> expression_s .
    (64) op_rel -> . LESSTHANOREQUAL
    (65) op_rel -> . GREATERTHANOREQUAL
    (66) op_rel -> . ISEQUALTO
    (67) op_rel -> . GREATERTHAN
    (68) op_rel -> . LESSTHAN

    DO              reduce using rule 44 (expression -> expression_s .)
    THEN            reduce using rule 44 (expression -> expression_s .)
    CLOSEPAR        reduce using rule 44 (expression -> expression_s .)
    GOTO            reduce using rule 44 (expression -> expression_s .)
    LABEL_SALTO     reduce using rule 44 (expression -> expression_s .)
    FOR             reduce using rule 44 (expression -> expression_s .)
    WHILE           reduce using rule 44 (expression -> expression_s .)
    IF              reduce using rule 44 (expression -> expression_s .)
    LET             reduce using rule 44 (expression -> expression_s .)
    CALL            reduce using rule 44 (expression -> expression_s .)
    INPUT           reduce using rule 44 (expression -> expression_s .)
    PRINT           reduce using rule 44 (expression -> expression_s .)
    NEXT            reduce using rule 44 (expression -> expression_s .)
    TO              reduce using rule 44 (expression -> expression_s .)
    RBRACKET        reduce using rule 44 (expression -> expression_s .)
    END             reduce using rule 44 (expression -> expression_s .)
    RETURN          reduce using rule 44 (expression -> expression_s .)
    LOOP            reduce using rule 44 (expression -> expression_s .)
    ELSE            reduce using rule 44 (expression -> expression_s .)
    LESSTHANOREQUAL shift and go to state 70
    GREATERTHANOREQUAL shift and go to state 71
    ISEQUALTO       shift and go to state 72
    GREATERTHAN     shift and go to state 73
    LESSTHAN        shift and go to state 74

    op_rel                         shift and go to state 69

state 39

    (45) expression_s -> term .
    (46) expression_s -> term . PLUS expression_s
    (47) expression_s -> term . MINUS expression_s
    (48) expression_s -> term . OR expression_s

    LESSTHANOREQUAL reduce using rule 45 (expression_s -> term .)
    GREATERTHANOREQUAL reduce using rule 45 (expression_s -> term .)
    ISEQUALTO       reduce using rule 45 (expression_s -> term .)
    GREATERTHAN     reduce using rule 45 (expression_s -> term .)
    LESSTHAN        reduce using rule 45 (expression_s -> term .)
    DO              reduce using rule 45 (expression_s -> term .)
    THEN            reduce using rule 45 (expression_s -> term .)
    CLOSEPAR        reduce using rule 45 (expression_s -> term .)
    GOTO            reduce using rule 45 (expression_s -> term .)
    LABEL_SALTO     reduce using rule 45 (expression_s -> term .)
    FOR             reduce using rule 45 (expression_s -> term .)
    WHILE           reduce using rule 45 (expression_s -> term .)
    IF              reduce using rule 45 (expression_s -> term .)
    LET             reduce using rule 45 (expression_s -> term .)
    CALL            reduce using rule 45 (expression_s -> term .)
    INPUT           reduce using rule 45 (expression_s -> term .)
    PRINT           reduce using rule 45 (expression_s -> term .)
    NEXT            reduce using rule 45 (expression_s -> term .)
    TO              reduce using rule 45 (expression_s -> term .)
    RBRACKET        reduce using rule 45 (expression_s -> term .)
    END             reduce using rule 45 (expression_s -> term .)
    RETURN          reduce using rule 45 (expression_s -> term .)
    LOOP            reduce using rule 45 (expression_s -> term .)
    ELSE            reduce using rule 45 (expression_s -> term .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    OR              shift and go to state 77


state 40

    (49) term -> factor .
    (50) term -> factor . MULTIPLY term
    (51) term -> factor . DIVIDE term
    (52) term -> factor . AND term

    PLUS            reduce using rule 49 (term -> factor .)
    MINUS           reduce using rule 49 (term -> factor .)
    OR              reduce using rule 49 (term -> factor .)
    LESSTHANOREQUAL reduce using rule 49 (term -> factor .)
    GREATERTHANOREQUAL reduce using rule 49 (term -> factor .)
    ISEQUALTO       reduce using rule 49 (term -> factor .)
    GREATERTHAN     reduce using rule 49 (term -> factor .)
    LESSTHAN        reduce using rule 49 (term -> factor .)
    DO              reduce using rule 49 (term -> factor .)
    THEN            reduce using rule 49 (term -> factor .)
    CLOSEPAR        reduce using rule 49 (term -> factor .)
    GOTO            reduce using rule 49 (term -> factor .)
    LABEL_SALTO     reduce using rule 49 (term -> factor .)
    FOR             reduce using rule 49 (term -> factor .)
    WHILE           reduce using rule 49 (term -> factor .)
    IF              reduce using rule 49 (term -> factor .)
    LET             reduce using rule 49 (term -> factor .)
    CALL            reduce using rule 49 (term -> factor .)
    INPUT           reduce using rule 49 (term -> factor .)
    PRINT           reduce using rule 49 (term -> factor .)
    NEXT            reduce using rule 49 (term -> factor .)
    TO              reduce using rule 49 (term -> factor .)
    RBRACKET        reduce using rule 49 (term -> factor .)
    END             reduce using rule 49 (term -> factor .)
    RETURN          reduce using rule 49 (term -> factor .)
    LOOP            reduce using rule 49 (term -> factor .)
    ELSE            reduce using rule 49 (term -> factor .)
    MULTIPLY        shift and go to state 78
    DIVIDE          shift and go to state 79
    AND             shift and go to state 80


state 41

    (53) factor -> elem .

    MULTIPLY        reduce using rule 53 (factor -> elem .)
    DIVIDE          reduce using rule 53 (factor -> elem .)
    AND             reduce using rule 53 (factor -> elem .)
    PLUS            reduce using rule 53 (factor -> elem .)
    MINUS           reduce using rule 53 (factor -> elem .)
    OR              reduce using rule 53 (factor -> elem .)
    LESSTHANOREQUAL reduce using rule 53 (factor -> elem .)
    GREATERTHANOREQUAL reduce using rule 53 (factor -> elem .)
    ISEQUALTO       reduce using rule 53 (factor -> elem .)
    GREATERTHAN     reduce using rule 53 (factor -> elem .)
    LESSTHAN        reduce using rule 53 (factor -> elem .)
    DO              reduce using rule 53 (factor -> elem .)
    THEN            reduce using rule 53 (factor -> elem .)
    CLOSEPAR        reduce using rule 53 (factor -> elem .)
    GOTO            reduce using rule 53 (factor -> elem .)
    LABEL_SALTO     reduce using rule 53 (factor -> elem .)
    FOR             reduce using rule 53 (factor -> elem .)
    WHILE           reduce using rule 53 (factor -> elem .)
    IF              reduce using rule 53 (factor -> elem .)
    LET             reduce using rule 53 (factor -> elem .)
    CALL            reduce using rule 53 (factor -> elem .)
    INPUT           reduce using rule 53 (factor -> elem .)
    PRINT           reduce using rule 53 (factor -> elem .)
    NEXT            reduce using rule 53 (factor -> elem .)
    TO              reduce using rule 53 (factor -> elem .)
    RBRACKET        reduce using rule 53 (factor -> elem .)
    END             reduce using rule 53 (factor -> elem .)
    RETURN          reduce using rule 53 (factor -> elem .)
    LOOP            reduce using rule 53 (factor -> elem .)
    ELSE            reduce using rule 53 (factor -> elem .)


state 42

    (54) factor -> OPENPAR . expression CLOSEPAR
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    expression                     shift and go to state 81
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 43

    (55) elem -> INT .

    MULTIPLY        reduce using rule 55 (elem -> INT .)
    DIVIDE          reduce using rule 55 (elem -> INT .)
    AND             reduce using rule 55 (elem -> INT .)
    PLUS            reduce using rule 55 (elem -> INT .)
    MINUS           reduce using rule 55 (elem -> INT .)
    OR              reduce using rule 55 (elem -> INT .)
    LESSTHANOREQUAL reduce using rule 55 (elem -> INT .)
    GREATERTHANOREQUAL reduce using rule 55 (elem -> INT .)
    ISEQUALTO       reduce using rule 55 (elem -> INT .)
    GREATERTHAN     reduce using rule 55 (elem -> INT .)
    LESSTHAN        reduce using rule 55 (elem -> INT .)
    DO              reduce using rule 55 (elem -> INT .)
    THEN            reduce using rule 55 (elem -> INT .)
    COMMA           reduce using rule 55 (elem -> INT .)
    GOTO            reduce using rule 55 (elem -> INT .)
    LABEL_SALTO     reduce using rule 55 (elem -> INT .)
    FOR             reduce using rule 55 (elem -> INT .)
    WHILE           reduce using rule 55 (elem -> INT .)
    IF              reduce using rule 55 (elem -> INT .)
    LET             reduce using rule 55 (elem -> INT .)
    CALL            reduce using rule 55 (elem -> INT .)
    INPUT           reduce using rule 55 (elem -> INT .)
    PRINT           reduce using rule 55 (elem -> INT .)
    END             reduce using rule 55 (elem -> INT .)
    RETURN          reduce using rule 55 (elem -> INT .)
    LOOP            reduce using rule 55 (elem -> INT .)
    ELSE            reduce using rule 55 (elem -> INT .)
    NEXT            reduce using rule 55 (elem -> INT .)
    CLOSEPAR        reduce using rule 55 (elem -> INT .)
    TO              reduce using rule 55 (elem -> INT .)
    RBRACKET        reduce using rule 55 (elem -> INT .)


state 44

    (56) elem -> aux_array .

    MULTIPLY        reduce using rule 56 (elem -> aux_array .)
    DIVIDE          reduce using rule 56 (elem -> aux_array .)
    AND             reduce using rule 56 (elem -> aux_array .)
    PLUS            reduce using rule 56 (elem -> aux_array .)
    MINUS           reduce using rule 56 (elem -> aux_array .)
    OR              reduce using rule 56 (elem -> aux_array .)
    LESSTHANOREQUAL reduce using rule 56 (elem -> aux_array .)
    GREATERTHANOREQUAL reduce using rule 56 (elem -> aux_array .)
    ISEQUALTO       reduce using rule 56 (elem -> aux_array .)
    GREATERTHAN     reduce using rule 56 (elem -> aux_array .)
    LESSTHAN        reduce using rule 56 (elem -> aux_array .)
    DO              reduce using rule 56 (elem -> aux_array .)
    THEN            reduce using rule 56 (elem -> aux_array .)
    COMMA           reduce using rule 56 (elem -> aux_array .)
    GOTO            reduce using rule 56 (elem -> aux_array .)
    LABEL_SALTO     reduce using rule 56 (elem -> aux_array .)
    FOR             reduce using rule 56 (elem -> aux_array .)
    WHILE           reduce using rule 56 (elem -> aux_array .)
    IF              reduce using rule 56 (elem -> aux_array .)
    LET             reduce using rule 56 (elem -> aux_array .)
    CALL            reduce using rule 56 (elem -> aux_array .)
    INPUT           reduce using rule 56 (elem -> aux_array .)
    PRINT           reduce using rule 56 (elem -> aux_array .)
    END             reduce using rule 56 (elem -> aux_array .)
    RETURN          reduce using rule 56 (elem -> aux_array .)
    LOOP            reduce using rule 56 (elem -> aux_array .)
    ELSE            reduce using rule 56 (elem -> aux_array .)
    NEXT            reduce using rule 56 (elem -> aux_array .)
    CLOSEPAR        reduce using rule 56 (elem -> aux_array .)
    TO              reduce using rule 56 (elem -> aux_array .)
    RBRACKET        reduce using rule 56 (elem -> aux_array .)


state 45

    (57) elem -> elem_else .

    MULTIPLY        reduce using rule 57 (elem -> elem_else .)
    DIVIDE          reduce using rule 57 (elem -> elem_else .)
    AND             reduce using rule 57 (elem -> elem_else .)
    PLUS            reduce using rule 57 (elem -> elem_else .)
    MINUS           reduce using rule 57 (elem -> elem_else .)
    OR              reduce using rule 57 (elem -> elem_else .)
    LESSTHANOREQUAL reduce using rule 57 (elem -> elem_else .)
    GREATERTHANOREQUAL reduce using rule 57 (elem -> elem_else .)
    ISEQUALTO       reduce using rule 57 (elem -> elem_else .)
    GREATERTHAN     reduce using rule 57 (elem -> elem_else .)
    LESSTHAN        reduce using rule 57 (elem -> elem_else .)
    DO              reduce using rule 57 (elem -> elem_else .)
    THEN            reduce using rule 57 (elem -> elem_else .)
    COMMA           reduce using rule 57 (elem -> elem_else .)
    GOTO            reduce using rule 57 (elem -> elem_else .)
    LABEL_SALTO     reduce using rule 57 (elem -> elem_else .)
    FOR             reduce using rule 57 (elem -> elem_else .)
    WHILE           reduce using rule 57 (elem -> elem_else .)
    IF              reduce using rule 57 (elem -> elem_else .)
    LET             reduce using rule 57 (elem -> elem_else .)
    CALL            reduce using rule 57 (elem -> elem_else .)
    INPUT           reduce using rule 57 (elem -> elem_else .)
    PRINT           reduce using rule 57 (elem -> elem_else .)
    END             reduce using rule 57 (elem -> elem_else .)
    RETURN          reduce using rule 57 (elem -> elem_else .)
    LOOP            reduce using rule 57 (elem -> elem_else .)
    ELSE            reduce using rule 57 (elem -> elem_else .)
    NEXT            reduce using rule 57 (elem -> elem_else .)
    CLOSEPAR        reduce using rule 57 (elem -> elem_else .)
    TO              reduce using rule 57 (elem -> elem_else .)
    RBRACKET        reduce using rule 57 (elem -> elem_else .)


state 46

    (58) aux_array -> size_identifier . repeated_size_access end_array
    (60) repeated_size_access -> . LBRACKET expression RBRACKET repeated_size_access
    (61) repeated_size_access -> . empty
    (69) empty -> .

    LBRACKET        shift and go to state 83
    MULTIPLY        reduce using rule 69 (empty -> .)
    DIVIDE          reduce using rule 69 (empty -> .)
    AND             reduce using rule 69 (empty -> .)
    PLUS            reduce using rule 69 (empty -> .)
    MINUS           reduce using rule 69 (empty -> .)
    OR              reduce using rule 69 (empty -> .)
    LESSTHANOREQUAL reduce using rule 69 (empty -> .)
    GREATERTHANOREQUAL reduce using rule 69 (empty -> .)
    ISEQUALTO       reduce using rule 69 (empty -> .)
    GREATERTHAN     reduce using rule 69 (empty -> .)
    LESSTHAN        reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    THEN            reduce using rule 69 (empty -> .)
    EQUALS          reduce using rule 69 (empty -> .)
    COMMA           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)
    RETURN          reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)
    ELSE            reduce using rule 69 (empty -> .)
    NEXT            reduce using rule 69 (empty -> .)
    CLOSEPAR        reduce using rule 69 (empty -> .)
    TO              reduce using rule 69 (empty -> .)
    RBRACKET        reduce using rule 69 (empty -> .)

    repeated_size_access           shift and go to state 82
    empty                          shift and go to state 84

state 47

    (63) elem_else -> FLOAT .

    MULTIPLY        reduce using rule 63 (elem_else -> FLOAT .)
    DIVIDE          reduce using rule 63 (elem_else -> FLOAT .)
    AND             reduce using rule 63 (elem_else -> FLOAT .)
    PLUS            reduce using rule 63 (elem_else -> FLOAT .)
    MINUS           reduce using rule 63 (elem_else -> FLOAT .)
    OR              reduce using rule 63 (elem_else -> FLOAT .)
    LESSTHANOREQUAL reduce using rule 63 (elem_else -> FLOAT .)
    GREATERTHANOREQUAL reduce using rule 63 (elem_else -> FLOAT .)
    ISEQUALTO       reduce using rule 63 (elem_else -> FLOAT .)
    GREATERTHAN     reduce using rule 63 (elem_else -> FLOAT .)
    LESSTHAN        reduce using rule 63 (elem_else -> FLOAT .)
    DO              reduce using rule 63 (elem_else -> FLOAT .)
    THEN            reduce using rule 63 (elem_else -> FLOAT .)
    COMMA           reduce using rule 63 (elem_else -> FLOAT .)
    GOTO            reduce using rule 63 (elem_else -> FLOAT .)
    LABEL_SALTO     reduce using rule 63 (elem_else -> FLOAT .)
    FOR             reduce using rule 63 (elem_else -> FLOAT .)
    WHILE           reduce using rule 63 (elem_else -> FLOAT .)
    IF              reduce using rule 63 (elem_else -> FLOAT .)
    LET             reduce using rule 63 (elem_else -> FLOAT .)
    CALL            reduce using rule 63 (elem_else -> FLOAT .)
    INPUT           reduce using rule 63 (elem_else -> FLOAT .)
    PRINT           reduce using rule 63 (elem_else -> FLOAT .)
    END             reduce using rule 63 (elem_else -> FLOAT .)
    RETURN          reduce using rule 63 (elem_else -> FLOAT .)
    LOOP            reduce using rule 63 (elem_else -> FLOAT .)
    ELSE            reduce using rule 63 (elem_else -> FLOAT .)
    NEXT            reduce using rule 63 (elem_else -> FLOAT .)
    CLOSEPAR        reduce using rule 63 (elem_else -> FLOAT .)
    TO              reduce using rule 63 (elem_else -> FLOAT .)
    RBRACKET        reduce using rule 63 (elem_else -> FLOAT .)


state 48

    (59) size_identifier -> IDENTIFIER .

    LBRACKET        reduce using rule 59 (size_identifier -> IDENTIFIER .)
    MULTIPLY        reduce using rule 59 (size_identifier -> IDENTIFIER .)
    DIVIDE          reduce using rule 59 (size_identifier -> IDENTIFIER .)
    AND             reduce using rule 59 (size_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 59 (size_identifier -> IDENTIFIER .)
    OR              reduce using rule 59 (size_identifier -> IDENTIFIER .)
    LESSTHANOREQUAL reduce using rule 59 (size_identifier -> IDENTIFIER .)
    GREATERTHANOREQUAL reduce using rule 59 (size_identifier -> IDENTIFIER .)
    ISEQUALTO       reduce using rule 59 (size_identifier -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 59 (size_identifier -> IDENTIFIER .)
    LESSTHAN        reduce using rule 59 (size_identifier -> IDENTIFIER .)
    DO              reduce using rule 59 (size_identifier -> IDENTIFIER .)
    THEN            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    EQUALS          reduce using rule 59 (size_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 59 (size_identifier -> IDENTIFIER .)
    GOTO            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    LABEL_SALTO     reduce using rule 59 (size_identifier -> IDENTIFIER .)
    FOR             reduce using rule 59 (size_identifier -> IDENTIFIER .)
    WHILE           reduce using rule 59 (size_identifier -> IDENTIFIER .)
    IF              reduce using rule 59 (size_identifier -> IDENTIFIER .)
    LET             reduce using rule 59 (size_identifier -> IDENTIFIER .)
    CALL            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    INPUT           reduce using rule 59 (size_identifier -> IDENTIFIER .)
    PRINT           reduce using rule 59 (size_identifier -> IDENTIFIER .)
    END             reduce using rule 59 (size_identifier -> IDENTIFIER .)
    RETURN          reduce using rule 59 (size_identifier -> IDENTIFIER .)
    LOOP            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    NEXT            reduce using rule 59 (size_identifier -> IDENTIFIER .)
    CLOSEPAR        reduce using rule 59 (size_identifier -> IDENTIFIER .)
    TO              reduce using rule 59 (size_identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 59 (size_identifier -> IDENTIFIER .)


state 49

    (27) statement -> IF aux_if . THEN block ELSE aux_else block END IF aux_fin

    THEN            shift and go to state 85


state 50

    (28) aux_if -> expression .

    THEN            reduce using rule 28 (aux_if -> expression .)


state 51

    (31) statement -> LET aux_array . EQUALS expression

    EQUALS          shift and go to state 86


state 52

    (32) statement -> CALL LABEL .

    GOTO            reduce using rule 32 (statement -> CALL LABEL .)
    LABEL_SALTO     reduce using rule 32 (statement -> CALL LABEL .)
    FOR             reduce using rule 32 (statement -> CALL LABEL .)
    DO              reduce using rule 32 (statement -> CALL LABEL .)
    WHILE           reduce using rule 32 (statement -> CALL LABEL .)
    IF              reduce using rule 32 (statement -> CALL LABEL .)
    LET             reduce using rule 32 (statement -> CALL LABEL .)
    CALL            reduce using rule 32 (statement -> CALL LABEL .)
    INPUT           reduce using rule 32 (statement -> CALL LABEL .)
    PRINT           reduce using rule 32 (statement -> CALL LABEL .)
    END             reduce using rule 32 (statement -> CALL LABEL .)
    RETURN          reduce using rule 32 (statement -> CALL LABEL .)
    LOOP            reduce using rule 32 (statement -> CALL LABEL .)
    ELSE            reduce using rule 32 (statement -> CALL LABEL .)
    NEXT            reduce using rule 32 (statement -> CALL LABEL .)


state 53

    (37) statement -> INPUT repeated_print .

    GOTO            reduce using rule 37 (statement -> INPUT repeated_print .)
    LABEL_SALTO     reduce using rule 37 (statement -> INPUT repeated_print .)
    FOR             reduce using rule 37 (statement -> INPUT repeated_print .)
    DO              reduce using rule 37 (statement -> INPUT repeated_print .)
    WHILE           reduce using rule 37 (statement -> INPUT repeated_print .)
    IF              reduce using rule 37 (statement -> INPUT repeated_print .)
    LET             reduce using rule 37 (statement -> INPUT repeated_print .)
    CALL            reduce using rule 37 (statement -> INPUT repeated_print .)
    INPUT           reduce using rule 37 (statement -> INPUT repeated_print .)
    PRINT           reduce using rule 37 (statement -> INPUT repeated_print .)
    END             reduce using rule 37 (statement -> INPUT repeated_print .)
    RETURN          reduce using rule 37 (statement -> INPUT repeated_print .)
    LOOP            reduce using rule 37 (statement -> INPUT repeated_print .)
    ELSE            reduce using rule 37 (statement -> INPUT repeated_print .)
    NEXT            reduce using rule 37 (statement -> INPUT repeated_print .)


state 54

    (39) repeated_print -> repeated_elem . COMMA repeated_print
    (40) repeated_print -> repeated_elem .

    COMMA           shift and go to state 87
    GOTO            reduce using rule 40 (repeated_print -> repeated_elem .)
    LABEL_SALTO     reduce using rule 40 (repeated_print -> repeated_elem .)
    FOR             reduce using rule 40 (repeated_print -> repeated_elem .)
    DO              reduce using rule 40 (repeated_print -> repeated_elem .)
    WHILE           reduce using rule 40 (repeated_print -> repeated_elem .)
    IF              reduce using rule 40 (repeated_print -> repeated_elem .)
    LET             reduce using rule 40 (repeated_print -> repeated_elem .)
    CALL            reduce using rule 40 (repeated_print -> repeated_elem .)
    INPUT           reduce using rule 40 (repeated_print -> repeated_elem .)
    PRINT           reduce using rule 40 (repeated_print -> repeated_elem .)
    END             reduce using rule 40 (repeated_print -> repeated_elem .)
    RETURN          reduce using rule 40 (repeated_print -> repeated_elem .)
    LOOP            reduce using rule 40 (repeated_print -> repeated_elem .)
    ELSE            reduce using rule 40 (repeated_print -> repeated_elem .)
    NEXT            reduce using rule 40 (repeated_print -> repeated_elem .)


state 55

    (41) repeated_elem -> STRING .

    COMMA           reduce using rule 41 (repeated_elem -> STRING .)
    GOTO            reduce using rule 41 (repeated_elem -> STRING .)
    LABEL_SALTO     reduce using rule 41 (repeated_elem -> STRING .)
    FOR             reduce using rule 41 (repeated_elem -> STRING .)
    DO              reduce using rule 41 (repeated_elem -> STRING .)
    WHILE           reduce using rule 41 (repeated_elem -> STRING .)
    IF              reduce using rule 41 (repeated_elem -> STRING .)
    LET             reduce using rule 41 (repeated_elem -> STRING .)
    CALL            reduce using rule 41 (repeated_elem -> STRING .)
    INPUT           reduce using rule 41 (repeated_elem -> STRING .)
    PRINT           reduce using rule 41 (repeated_elem -> STRING .)
    END             reduce using rule 41 (repeated_elem -> STRING .)
    RETURN          reduce using rule 41 (repeated_elem -> STRING .)
    LOOP            reduce using rule 41 (repeated_elem -> STRING .)
    ELSE            reduce using rule 41 (repeated_elem -> STRING .)
    NEXT            reduce using rule 41 (repeated_elem -> STRING .)


state 56

    (42) repeated_elem -> elem .

    COMMA           reduce using rule 42 (repeated_elem -> elem .)
    GOTO            reduce using rule 42 (repeated_elem -> elem .)
    LABEL_SALTO     reduce using rule 42 (repeated_elem -> elem .)
    FOR             reduce using rule 42 (repeated_elem -> elem .)
    DO              reduce using rule 42 (repeated_elem -> elem .)
    WHILE           reduce using rule 42 (repeated_elem -> elem .)
    IF              reduce using rule 42 (repeated_elem -> elem .)
    LET             reduce using rule 42 (repeated_elem -> elem .)
    CALL            reduce using rule 42 (repeated_elem -> elem .)
    INPUT           reduce using rule 42 (repeated_elem -> elem .)
    PRINT           reduce using rule 42 (repeated_elem -> elem .)
    END             reduce using rule 42 (repeated_elem -> elem .)
    RETURN          reduce using rule 42 (repeated_elem -> elem .)
    LOOP            reduce using rule 42 (repeated_elem -> elem .)
    ELSE            reduce using rule 42 (repeated_elem -> elem .)
    NEXT            reduce using rule 42 (repeated_elem -> elem .)


state 57

    (38) statement -> PRINT repeated_print .

    GOTO            reduce using rule 38 (statement -> PRINT repeated_print .)
    LABEL_SALTO     reduce using rule 38 (statement -> PRINT repeated_print .)
    FOR             reduce using rule 38 (statement -> PRINT repeated_print .)
    DO              reduce using rule 38 (statement -> PRINT repeated_print .)
    WHILE           reduce using rule 38 (statement -> PRINT repeated_print .)
    IF              reduce using rule 38 (statement -> PRINT repeated_print .)
    LET             reduce using rule 38 (statement -> PRINT repeated_print .)
    CALL            reduce using rule 38 (statement -> PRINT repeated_print .)
    INPUT           reduce using rule 38 (statement -> PRINT repeated_print .)
    PRINT           reduce using rule 38 (statement -> PRINT repeated_print .)
    END             reduce using rule 38 (statement -> PRINT repeated_print .)
    RETURN          reduce using rule 38 (statement -> PRINT repeated_print .)
    LOOP            reduce using rule 38 (statement -> PRINT repeated_print .)
    ELSE            reduce using rule 38 (statement -> PRINT repeated_print .)
    NEXT            reduce using rule 38 (statement -> PRINT repeated_print .)


state 58

    (33) procedure -> aux_label block aux_return . procedure
    (33) procedure -> . aux_label block aux_return procedure
    (34) procedure -> . empty
    (35) aux_label -> . LABEL
    (69) empty -> .

    LABEL           shift and go to state 10
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    aux_label                      shift and go to state 8
    procedure                      shift and go to state 88
    empty                          shift and go to state 9

state 59

    (36) aux_return -> RETURN .

    LABEL           reduce using rule 36 (aux_return -> RETURN .)
    GOTO            reduce using rule 36 (aux_return -> RETURN .)
    LABEL_SALTO     reduce using rule 36 (aux_return -> RETURN .)
    FOR             reduce using rule 36 (aux_return -> RETURN .)
    DO              reduce using rule 36 (aux_return -> RETURN .)
    WHILE           reduce using rule 36 (aux_return -> RETURN .)
    IF              reduce using rule 36 (aux_return -> RETURN .)
    LET             reduce using rule 36 (aux_return -> RETURN .)
    CALL            reduce using rule 36 (aux_return -> RETURN .)
    INPUT           reduce using rule 36 (aux_return -> RETURN .)
    PRINT           reduce using rule 36 (aux_return -> RETURN .)
    END             reduce using rule 36 (aux_return -> RETURN .)


state 60

    (3) var -> DIM repeated_identifier AS type . repeated_size aux_size var
    (6) repeated_size -> . LBRACKET INT RBRACKET repeated_size
    (7) repeated_size -> . empty
    (69) empty -> .

    LBRACKET        shift and go to state 90
    DIM             reduce using rule 69 (empty -> .)
    LABEL           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    repeated_size                  shift and go to state 89
    empty                          shift and go to state 91

state 61

    (4) var -> DIM repeated_identifier AS STRING_TYPE . var
    (3) var -> . DIM repeated_identifier AS type repeated_size aux_size var
    (4) var -> . DIM repeated_identifier AS STRING_TYPE var
    (5) var -> . empty
    (69) empty -> .

    DIM             shift and go to state 5
    LABEL           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    var                            shift and go to state 92
    empty                          shift and go to state 6

state 62

    (11) type -> INT_TYPE .

    LBRACKET        reduce using rule 11 (type -> INT_TYPE .)
    DIM             reduce using rule 11 (type -> INT_TYPE .)
    LABEL           reduce using rule 11 (type -> INT_TYPE .)
    GOTO            reduce using rule 11 (type -> INT_TYPE .)
    LABEL_SALTO     reduce using rule 11 (type -> INT_TYPE .)
    FOR             reduce using rule 11 (type -> INT_TYPE .)
    DO              reduce using rule 11 (type -> INT_TYPE .)
    WHILE           reduce using rule 11 (type -> INT_TYPE .)
    IF              reduce using rule 11 (type -> INT_TYPE .)
    LET             reduce using rule 11 (type -> INT_TYPE .)
    CALL            reduce using rule 11 (type -> INT_TYPE .)
    INPUT           reduce using rule 11 (type -> INT_TYPE .)
    PRINT           reduce using rule 11 (type -> INT_TYPE .)
    END             reduce using rule 11 (type -> INT_TYPE .)


state 63

    (12) type -> FLOAT_TYPE .

    LBRACKET        reduce using rule 12 (type -> FLOAT_TYPE .)
    DIM             reduce using rule 12 (type -> FLOAT_TYPE .)
    LABEL           reduce using rule 12 (type -> FLOAT_TYPE .)
    GOTO            reduce using rule 12 (type -> FLOAT_TYPE .)
    LABEL_SALTO     reduce using rule 12 (type -> FLOAT_TYPE .)
    FOR             reduce using rule 12 (type -> FLOAT_TYPE .)
    DO              reduce using rule 12 (type -> FLOAT_TYPE .)
    WHILE           reduce using rule 12 (type -> FLOAT_TYPE .)
    IF              reduce using rule 12 (type -> FLOAT_TYPE .)
    LET             reduce using rule 12 (type -> FLOAT_TYPE .)
    CALL            reduce using rule 12 (type -> FLOAT_TYPE .)
    INPUT           reduce using rule 12 (type -> FLOAT_TYPE .)
    PRINT           reduce using rule 12 (type -> FLOAT_TYPE .)
    END             reduce using rule 12 (type -> FLOAT_TYPE .)


state 64

    (9) repeated_identifier -> IDENTIFIER COMMA repeated_identifier .

    AS              reduce using rule 9 (repeated_identifier -> IDENTIFIER COMMA repeated_identifier .)


state 65

    (17) statement -> FOR aux1 TO . aux2 block NEXT aux3
    (19) aux2 -> . expression
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    aux2                           shift and go to state 93
    expression                     shift and go to state 94
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 66

    (18) aux1 -> IDENTIFIER EQUALS . expression
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    expression                     shift and go to state 95
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 67

    (21) statement -> DO do_while_inicio block . LOOP WHILE aux_do_while

    LOOP            shift and go to state 96


state 68

    (24) statement -> WHILE aux_while DO . block LOOP fin_while
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    LOOP            reduce using rule 69 (empty -> .)

    block                          shift and go to state 97
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 69

    (43) expression -> expression_s op_rel . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    expression_s                   shift and go to state 98
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 70

    (64) op_rel -> LESSTHANOREQUAL .

    OPENPAR         reduce using rule 64 (op_rel -> LESSTHANOREQUAL .)
    INT             reduce using rule 64 (op_rel -> LESSTHANOREQUAL .)
    FLOAT           reduce using rule 64 (op_rel -> LESSTHANOREQUAL .)
    IDENTIFIER      reduce using rule 64 (op_rel -> LESSTHANOREQUAL .)


state 71

    (65) op_rel -> GREATERTHANOREQUAL .

    OPENPAR         reduce using rule 65 (op_rel -> GREATERTHANOREQUAL .)
    INT             reduce using rule 65 (op_rel -> GREATERTHANOREQUAL .)
    FLOAT           reduce using rule 65 (op_rel -> GREATERTHANOREQUAL .)
    IDENTIFIER      reduce using rule 65 (op_rel -> GREATERTHANOREQUAL .)


state 72

    (66) op_rel -> ISEQUALTO .

    OPENPAR         reduce using rule 66 (op_rel -> ISEQUALTO .)
    INT             reduce using rule 66 (op_rel -> ISEQUALTO .)
    FLOAT           reduce using rule 66 (op_rel -> ISEQUALTO .)
    IDENTIFIER      reduce using rule 66 (op_rel -> ISEQUALTO .)


state 73

    (67) op_rel -> GREATERTHAN .

    OPENPAR         reduce using rule 67 (op_rel -> GREATERTHAN .)
    INT             reduce using rule 67 (op_rel -> GREATERTHAN .)
    FLOAT           reduce using rule 67 (op_rel -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 67 (op_rel -> GREATERTHAN .)


state 74

    (68) op_rel -> LESSTHAN .

    OPENPAR         reduce using rule 68 (op_rel -> LESSTHAN .)
    INT             reduce using rule 68 (op_rel -> LESSTHAN .)
    FLOAT           reduce using rule 68 (op_rel -> LESSTHAN .)
    IDENTIFIER      reduce using rule 68 (op_rel -> LESSTHAN .)


state 75

    (46) expression_s -> term PLUS . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    term                           shift and go to state 39
    expression_s                   shift and go to state 99
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 76

    (47) expression_s -> term MINUS . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    term                           shift and go to state 39
    expression_s                   shift and go to state 100
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 77

    (48) expression_s -> term OR . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    term                           shift and go to state 39
    expression_s                   shift and go to state 101
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 78

    (50) term -> factor MULTIPLY . term
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    factor                         shift and go to state 40
    term                           shift and go to state 102
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 79

    (51) term -> factor DIVIDE . term
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    factor                         shift and go to state 40
    term                           shift and go to state 103
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 80

    (52) term -> factor AND . term
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    factor                         shift and go to state 40
    term                           shift and go to state 104
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 81

    (54) factor -> OPENPAR expression . CLOSEPAR

    CLOSEPAR        shift and go to state 105


state 82

    (58) aux_array -> size_identifier repeated_size_access . end_array
    (62) end_array -> . empty
    (69) empty -> .

    MULTIPLY        reduce using rule 69 (empty -> .)
    DIVIDE          reduce using rule 69 (empty -> .)
    AND             reduce using rule 69 (empty -> .)
    PLUS            reduce using rule 69 (empty -> .)
    MINUS           reduce using rule 69 (empty -> .)
    OR              reduce using rule 69 (empty -> .)
    LESSTHANOREQUAL reduce using rule 69 (empty -> .)
    GREATERTHANOREQUAL reduce using rule 69 (empty -> .)
    ISEQUALTO       reduce using rule 69 (empty -> .)
    GREATERTHAN     reduce using rule 69 (empty -> .)
    LESSTHAN        reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    THEN            reduce using rule 69 (empty -> .)
    EQUALS          reduce using rule 69 (empty -> .)
    COMMA           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)
    RETURN          reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)
    ELSE            reduce using rule 69 (empty -> .)
    NEXT            reduce using rule 69 (empty -> .)
    CLOSEPAR        reduce using rule 69 (empty -> .)
    TO              reduce using rule 69 (empty -> .)
    RBRACKET        reduce using rule 69 (empty -> .)

    end_array                      shift and go to state 106
    empty                          shift and go to state 107

state 83

    (60) repeated_size_access -> LBRACKET . expression RBRACKET repeated_size_access
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    expression                     shift and go to state 108
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 84

    (61) repeated_size_access -> empty .

    MULTIPLY        reduce using rule 61 (repeated_size_access -> empty .)
    DIVIDE          reduce using rule 61 (repeated_size_access -> empty .)
    AND             reduce using rule 61 (repeated_size_access -> empty .)
    PLUS            reduce using rule 61 (repeated_size_access -> empty .)
    MINUS           reduce using rule 61 (repeated_size_access -> empty .)
    OR              reduce using rule 61 (repeated_size_access -> empty .)
    LESSTHANOREQUAL reduce using rule 61 (repeated_size_access -> empty .)
    GREATERTHANOREQUAL reduce using rule 61 (repeated_size_access -> empty .)
    ISEQUALTO       reduce using rule 61 (repeated_size_access -> empty .)
    GREATERTHAN     reduce using rule 61 (repeated_size_access -> empty .)
    LESSTHAN        reduce using rule 61 (repeated_size_access -> empty .)
    DO              reduce using rule 61 (repeated_size_access -> empty .)
    THEN            reduce using rule 61 (repeated_size_access -> empty .)
    EQUALS          reduce using rule 61 (repeated_size_access -> empty .)
    COMMA           reduce using rule 61 (repeated_size_access -> empty .)
    GOTO            reduce using rule 61 (repeated_size_access -> empty .)
    LABEL_SALTO     reduce using rule 61 (repeated_size_access -> empty .)
    FOR             reduce using rule 61 (repeated_size_access -> empty .)
    WHILE           reduce using rule 61 (repeated_size_access -> empty .)
    IF              reduce using rule 61 (repeated_size_access -> empty .)
    LET             reduce using rule 61 (repeated_size_access -> empty .)
    CALL            reduce using rule 61 (repeated_size_access -> empty .)
    INPUT           reduce using rule 61 (repeated_size_access -> empty .)
    PRINT           reduce using rule 61 (repeated_size_access -> empty .)
    END             reduce using rule 61 (repeated_size_access -> empty .)
    RETURN          reduce using rule 61 (repeated_size_access -> empty .)
    LOOP            reduce using rule 61 (repeated_size_access -> empty .)
    ELSE            reduce using rule 61 (repeated_size_access -> empty .)
    NEXT            reduce using rule 61 (repeated_size_access -> empty .)
    CLOSEPAR        reduce using rule 61 (repeated_size_access -> empty .)
    TO              reduce using rule 61 (repeated_size_access -> empty .)
    RBRACKET        reduce using rule 61 (repeated_size_access -> empty .)


state 85

    (27) statement -> IF aux_if THEN . block ELSE aux_else block END IF aux_fin
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    ELSE            reduce using rule 69 (empty -> .)

    block                          shift and go to state 109
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 86

    (31) statement -> LET aux_array EQUALS . expression
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    aux_array                      shift and go to state 44
    expression                     shift and go to state 110
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 87

    (39) repeated_print -> repeated_elem COMMA . repeated_print
    (39) repeated_print -> . repeated_elem COMMA repeated_print
    (40) repeated_print -> . repeated_elem
    (41) repeated_elem -> . STRING
    (42) repeated_elem -> . elem
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    STRING          shift and go to state 55
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    repeated_elem                  shift and go to state 54
    repeated_print                 shift and go to state 111
    elem                           shift and go to state 56
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 88

    (33) procedure -> aux_label block aux_return procedure .

    GOTO            reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    LABEL_SALTO     reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    FOR             reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    DO              reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    WHILE           reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    IF              reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    LET             reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    CALL            reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    INPUT           reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    PRINT           reduce using rule 33 (procedure -> aux_label block aux_return procedure .)
    END             reduce using rule 33 (procedure -> aux_label block aux_return procedure .)


state 89

    (3) var -> DIM repeated_identifier AS type repeated_size . aux_size var
    (8) aux_size -> . empty
    (69) empty -> .

    DIM             reduce using rule 69 (empty -> .)
    LABEL           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    aux_size                       shift and go to state 112
    empty                          shift and go to state 113

state 90

    (6) repeated_size -> LBRACKET . INT RBRACKET repeated_size

    INT             shift and go to state 114


state 91

    (7) repeated_size -> empty .

    DIM             reduce using rule 7 (repeated_size -> empty .)
    LABEL           reduce using rule 7 (repeated_size -> empty .)
    GOTO            reduce using rule 7 (repeated_size -> empty .)
    LABEL_SALTO     reduce using rule 7 (repeated_size -> empty .)
    FOR             reduce using rule 7 (repeated_size -> empty .)
    DO              reduce using rule 7 (repeated_size -> empty .)
    WHILE           reduce using rule 7 (repeated_size -> empty .)
    IF              reduce using rule 7 (repeated_size -> empty .)
    LET             reduce using rule 7 (repeated_size -> empty .)
    CALL            reduce using rule 7 (repeated_size -> empty .)
    INPUT           reduce using rule 7 (repeated_size -> empty .)
    PRINT           reduce using rule 7 (repeated_size -> empty .)
    END             reduce using rule 7 (repeated_size -> empty .)


state 92

    (4) var -> DIM repeated_identifier AS STRING_TYPE var .

    LABEL           reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    GOTO            reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    LABEL_SALTO     reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    FOR             reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    DO              reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    WHILE           reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    IF              reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    LET             reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    CALL            reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    INPUT           reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    PRINT           reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)
    END             reduce using rule 4 (var -> DIM repeated_identifier AS STRING_TYPE var .)


state 93

    (17) statement -> FOR aux1 TO aux2 . block NEXT aux3
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    NEXT            reduce using rule 69 (empty -> .)

    block                          shift and go to state 115
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 94

    (19) aux2 -> expression .

    GOTO            reduce using rule 19 (aux2 -> expression .)
    LABEL_SALTO     reduce using rule 19 (aux2 -> expression .)
    FOR             reduce using rule 19 (aux2 -> expression .)
    DO              reduce using rule 19 (aux2 -> expression .)
    WHILE           reduce using rule 19 (aux2 -> expression .)
    IF              reduce using rule 19 (aux2 -> expression .)
    LET             reduce using rule 19 (aux2 -> expression .)
    CALL            reduce using rule 19 (aux2 -> expression .)
    INPUT           reduce using rule 19 (aux2 -> expression .)
    PRINT           reduce using rule 19 (aux2 -> expression .)
    NEXT            reduce using rule 19 (aux2 -> expression .)


state 95

    (18) aux1 -> IDENTIFIER EQUALS expression .

    TO              reduce using rule 18 (aux1 -> IDENTIFIER EQUALS expression .)


state 96

    (21) statement -> DO do_while_inicio block LOOP . WHILE aux_do_while

    WHILE           shift and go to state 116


state 97

    (24) statement -> WHILE aux_while DO block . LOOP fin_while

    LOOP            shift and go to state 117


state 98

    (43) expression -> expression_s op_rel expression_s .

    DO              reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    THEN            reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    CLOSEPAR        reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    GOTO            reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    LABEL_SALTO     reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    FOR             reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    WHILE           reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    IF              reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    LET             reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    CALL            reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    INPUT           reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    PRINT           reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    NEXT            reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    TO              reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    RBRACKET        reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    END             reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    RETURN          reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    LOOP            reduce using rule 43 (expression -> expression_s op_rel expression_s .)
    ELSE            reduce using rule 43 (expression -> expression_s op_rel expression_s .)


state 99

    (46) expression_s -> term PLUS expression_s .

    LESSTHANOREQUAL reduce using rule 46 (expression_s -> term PLUS expression_s .)
    GREATERTHANOREQUAL reduce using rule 46 (expression_s -> term PLUS expression_s .)
    ISEQUALTO       reduce using rule 46 (expression_s -> term PLUS expression_s .)
    GREATERTHAN     reduce using rule 46 (expression_s -> term PLUS expression_s .)
    LESSTHAN        reduce using rule 46 (expression_s -> term PLUS expression_s .)
    DO              reduce using rule 46 (expression_s -> term PLUS expression_s .)
    THEN            reduce using rule 46 (expression_s -> term PLUS expression_s .)
    CLOSEPAR        reduce using rule 46 (expression_s -> term PLUS expression_s .)
    GOTO            reduce using rule 46 (expression_s -> term PLUS expression_s .)
    LABEL_SALTO     reduce using rule 46 (expression_s -> term PLUS expression_s .)
    FOR             reduce using rule 46 (expression_s -> term PLUS expression_s .)
    WHILE           reduce using rule 46 (expression_s -> term PLUS expression_s .)
    IF              reduce using rule 46 (expression_s -> term PLUS expression_s .)
    LET             reduce using rule 46 (expression_s -> term PLUS expression_s .)
    CALL            reduce using rule 46 (expression_s -> term PLUS expression_s .)
    INPUT           reduce using rule 46 (expression_s -> term PLUS expression_s .)
    PRINT           reduce using rule 46 (expression_s -> term PLUS expression_s .)
    NEXT            reduce using rule 46 (expression_s -> term PLUS expression_s .)
    TO              reduce using rule 46 (expression_s -> term PLUS expression_s .)
    RBRACKET        reduce using rule 46 (expression_s -> term PLUS expression_s .)
    END             reduce using rule 46 (expression_s -> term PLUS expression_s .)
    RETURN          reduce using rule 46 (expression_s -> term PLUS expression_s .)
    LOOP            reduce using rule 46 (expression_s -> term PLUS expression_s .)
    ELSE            reduce using rule 46 (expression_s -> term PLUS expression_s .)


state 100

    (47) expression_s -> term MINUS expression_s .

    LESSTHANOREQUAL reduce using rule 47 (expression_s -> term MINUS expression_s .)
    GREATERTHANOREQUAL reduce using rule 47 (expression_s -> term MINUS expression_s .)
    ISEQUALTO       reduce using rule 47 (expression_s -> term MINUS expression_s .)
    GREATERTHAN     reduce using rule 47 (expression_s -> term MINUS expression_s .)
    LESSTHAN        reduce using rule 47 (expression_s -> term MINUS expression_s .)
    DO              reduce using rule 47 (expression_s -> term MINUS expression_s .)
    THEN            reduce using rule 47 (expression_s -> term MINUS expression_s .)
    CLOSEPAR        reduce using rule 47 (expression_s -> term MINUS expression_s .)
    GOTO            reduce using rule 47 (expression_s -> term MINUS expression_s .)
    LABEL_SALTO     reduce using rule 47 (expression_s -> term MINUS expression_s .)
    FOR             reduce using rule 47 (expression_s -> term MINUS expression_s .)
    WHILE           reduce using rule 47 (expression_s -> term MINUS expression_s .)
    IF              reduce using rule 47 (expression_s -> term MINUS expression_s .)
    LET             reduce using rule 47 (expression_s -> term MINUS expression_s .)
    CALL            reduce using rule 47 (expression_s -> term MINUS expression_s .)
    INPUT           reduce using rule 47 (expression_s -> term MINUS expression_s .)
    PRINT           reduce using rule 47 (expression_s -> term MINUS expression_s .)
    NEXT            reduce using rule 47 (expression_s -> term MINUS expression_s .)
    TO              reduce using rule 47 (expression_s -> term MINUS expression_s .)
    RBRACKET        reduce using rule 47 (expression_s -> term MINUS expression_s .)
    END             reduce using rule 47 (expression_s -> term MINUS expression_s .)
    RETURN          reduce using rule 47 (expression_s -> term MINUS expression_s .)
    LOOP            reduce using rule 47 (expression_s -> term MINUS expression_s .)
    ELSE            reduce using rule 47 (expression_s -> term MINUS expression_s .)


state 101

    (48) expression_s -> term OR expression_s .

    LESSTHANOREQUAL reduce using rule 48 (expression_s -> term OR expression_s .)
    GREATERTHANOREQUAL reduce using rule 48 (expression_s -> term OR expression_s .)
    ISEQUALTO       reduce using rule 48 (expression_s -> term OR expression_s .)
    GREATERTHAN     reduce using rule 48 (expression_s -> term OR expression_s .)
    LESSTHAN        reduce using rule 48 (expression_s -> term OR expression_s .)
    DO              reduce using rule 48 (expression_s -> term OR expression_s .)
    THEN            reduce using rule 48 (expression_s -> term OR expression_s .)
    CLOSEPAR        reduce using rule 48 (expression_s -> term OR expression_s .)
    GOTO            reduce using rule 48 (expression_s -> term OR expression_s .)
    LABEL_SALTO     reduce using rule 48 (expression_s -> term OR expression_s .)
    FOR             reduce using rule 48 (expression_s -> term OR expression_s .)
    WHILE           reduce using rule 48 (expression_s -> term OR expression_s .)
    IF              reduce using rule 48 (expression_s -> term OR expression_s .)
    LET             reduce using rule 48 (expression_s -> term OR expression_s .)
    CALL            reduce using rule 48 (expression_s -> term OR expression_s .)
    INPUT           reduce using rule 48 (expression_s -> term OR expression_s .)
    PRINT           reduce using rule 48 (expression_s -> term OR expression_s .)
    NEXT            reduce using rule 48 (expression_s -> term OR expression_s .)
    TO              reduce using rule 48 (expression_s -> term OR expression_s .)
    RBRACKET        reduce using rule 48 (expression_s -> term OR expression_s .)
    END             reduce using rule 48 (expression_s -> term OR expression_s .)
    RETURN          reduce using rule 48 (expression_s -> term OR expression_s .)
    LOOP            reduce using rule 48 (expression_s -> term OR expression_s .)
    ELSE            reduce using rule 48 (expression_s -> term OR expression_s .)


state 102

    (50) term -> factor MULTIPLY term .

    PLUS            reduce using rule 50 (term -> factor MULTIPLY term .)
    MINUS           reduce using rule 50 (term -> factor MULTIPLY term .)
    OR              reduce using rule 50 (term -> factor MULTIPLY term .)
    LESSTHANOREQUAL reduce using rule 50 (term -> factor MULTIPLY term .)
    GREATERTHANOREQUAL reduce using rule 50 (term -> factor MULTIPLY term .)
    ISEQUALTO       reduce using rule 50 (term -> factor MULTIPLY term .)
    GREATERTHAN     reduce using rule 50 (term -> factor MULTIPLY term .)
    LESSTHAN        reduce using rule 50 (term -> factor MULTIPLY term .)
    DO              reduce using rule 50 (term -> factor MULTIPLY term .)
    THEN            reduce using rule 50 (term -> factor MULTIPLY term .)
    CLOSEPAR        reduce using rule 50 (term -> factor MULTIPLY term .)
    GOTO            reduce using rule 50 (term -> factor MULTIPLY term .)
    LABEL_SALTO     reduce using rule 50 (term -> factor MULTIPLY term .)
    FOR             reduce using rule 50 (term -> factor MULTIPLY term .)
    WHILE           reduce using rule 50 (term -> factor MULTIPLY term .)
    IF              reduce using rule 50 (term -> factor MULTIPLY term .)
    LET             reduce using rule 50 (term -> factor MULTIPLY term .)
    CALL            reduce using rule 50 (term -> factor MULTIPLY term .)
    INPUT           reduce using rule 50 (term -> factor MULTIPLY term .)
    PRINT           reduce using rule 50 (term -> factor MULTIPLY term .)
    NEXT            reduce using rule 50 (term -> factor MULTIPLY term .)
    TO              reduce using rule 50 (term -> factor MULTIPLY term .)
    RBRACKET        reduce using rule 50 (term -> factor MULTIPLY term .)
    END             reduce using rule 50 (term -> factor MULTIPLY term .)
    RETURN          reduce using rule 50 (term -> factor MULTIPLY term .)
    LOOP            reduce using rule 50 (term -> factor MULTIPLY term .)
    ELSE            reduce using rule 50 (term -> factor MULTIPLY term .)


state 103

    (51) term -> factor DIVIDE term .

    PLUS            reduce using rule 51 (term -> factor DIVIDE term .)
    MINUS           reduce using rule 51 (term -> factor DIVIDE term .)
    OR              reduce using rule 51 (term -> factor DIVIDE term .)
    LESSTHANOREQUAL reduce using rule 51 (term -> factor DIVIDE term .)
    GREATERTHANOREQUAL reduce using rule 51 (term -> factor DIVIDE term .)
    ISEQUALTO       reduce using rule 51 (term -> factor DIVIDE term .)
    GREATERTHAN     reduce using rule 51 (term -> factor DIVIDE term .)
    LESSTHAN        reduce using rule 51 (term -> factor DIVIDE term .)
    DO              reduce using rule 51 (term -> factor DIVIDE term .)
    THEN            reduce using rule 51 (term -> factor DIVIDE term .)
    CLOSEPAR        reduce using rule 51 (term -> factor DIVIDE term .)
    GOTO            reduce using rule 51 (term -> factor DIVIDE term .)
    LABEL_SALTO     reduce using rule 51 (term -> factor DIVIDE term .)
    FOR             reduce using rule 51 (term -> factor DIVIDE term .)
    WHILE           reduce using rule 51 (term -> factor DIVIDE term .)
    IF              reduce using rule 51 (term -> factor DIVIDE term .)
    LET             reduce using rule 51 (term -> factor DIVIDE term .)
    CALL            reduce using rule 51 (term -> factor DIVIDE term .)
    INPUT           reduce using rule 51 (term -> factor DIVIDE term .)
    PRINT           reduce using rule 51 (term -> factor DIVIDE term .)
    NEXT            reduce using rule 51 (term -> factor DIVIDE term .)
    TO              reduce using rule 51 (term -> factor DIVIDE term .)
    RBRACKET        reduce using rule 51 (term -> factor DIVIDE term .)
    END             reduce using rule 51 (term -> factor DIVIDE term .)
    RETURN          reduce using rule 51 (term -> factor DIVIDE term .)
    LOOP            reduce using rule 51 (term -> factor DIVIDE term .)
    ELSE            reduce using rule 51 (term -> factor DIVIDE term .)


state 104

    (52) term -> factor AND term .

    PLUS            reduce using rule 52 (term -> factor AND term .)
    MINUS           reduce using rule 52 (term -> factor AND term .)
    OR              reduce using rule 52 (term -> factor AND term .)
    LESSTHANOREQUAL reduce using rule 52 (term -> factor AND term .)
    GREATERTHANOREQUAL reduce using rule 52 (term -> factor AND term .)
    ISEQUALTO       reduce using rule 52 (term -> factor AND term .)
    GREATERTHAN     reduce using rule 52 (term -> factor AND term .)
    LESSTHAN        reduce using rule 52 (term -> factor AND term .)
    DO              reduce using rule 52 (term -> factor AND term .)
    THEN            reduce using rule 52 (term -> factor AND term .)
    CLOSEPAR        reduce using rule 52 (term -> factor AND term .)
    GOTO            reduce using rule 52 (term -> factor AND term .)
    LABEL_SALTO     reduce using rule 52 (term -> factor AND term .)
    FOR             reduce using rule 52 (term -> factor AND term .)
    WHILE           reduce using rule 52 (term -> factor AND term .)
    IF              reduce using rule 52 (term -> factor AND term .)
    LET             reduce using rule 52 (term -> factor AND term .)
    CALL            reduce using rule 52 (term -> factor AND term .)
    INPUT           reduce using rule 52 (term -> factor AND term .)
    PRINT           reduce using rule 52 (term -> factor AND term .)
    NEXT            reduce using rule 52 (term -> factor AND term .)
    TO              reduce using rule 52 (term -> factor AND term .)
    RBRACKET        reduce using rule 52 (term -> factor AND term .)
    END             reduce using rule 52 (term -> factor AND term .)
    RETURN          reduce using rule 52 (term -> factor AND term .)
    LOOP            reduce using rule 52 (term -> factor AND term .)
    ELSE            reduce using rule 52 (term -> factor AND term .)


state 105

    (54) factor -> OPENPAR expression CLOSEPAR .

    MULTIPLY        reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    DIVIDE          reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    AND             reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    PLUS            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    MINUS           reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    OR              reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    LESSTHANOREQUAL reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    GREATERTHANOREQUAL reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    ISEQUALTO       reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    GREATERTHAN     reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    LESSTHAN        reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    DO              reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    THEN            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    CLOSEPAR        reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    GOTO            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    LABEL_SALTO     reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    FOR             reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    WHILE           reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    IF              reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    LET             reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    CALL            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    INPUT           reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    PRINT           reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    NEXT            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    TO              reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    RBRACKET        reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    END             reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    RETURN          reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    LOOP            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)
    ELSE            reduce using rule 54 (factor -> OPENPAR expression CLOSEPAR .)


state 106

    (58) aux_array -> size_identifier repeated_size_access end_array .

    MULTIPLY        reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    DIVIDE          reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    AND             reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    PLUS            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    MINUS           reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    OR              reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    LESSTHANOREQUAL reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    GREATERTHANOREQUAL reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    ISEQUALTO       reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    GREATERTHAN     reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    LESSTHAN        reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    DO              reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    THEN            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    EQUALS          reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    COMMA           reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    GOTO            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    LABEL_SALTO     reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    FOR             reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    WHILE           reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    IF              reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    LET             reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    CALL            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    INPUT           reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    PRINT           reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    END             reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    RETURN          reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    LOOP            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    ELSE            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    NEXT            reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    CLOSEPAR        reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    TO              reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)
    RBRACKET        reduce using rule 58 (aux_array -> size_identifier repeated_size_access end_array .)


state 107

    (62) end_array -> empty .

    MULTIPLY        reduce using rule 62 (end_array -> empty .)
    DIVIDE          reduce using rule 62 (end_array -> empty .)
    AND             reduce using rule 62 (end_array -> empty .)
    PLUS            reduce using rule 62 (end_array -> empty .)
    MINUS           reduce using rule 62 (end_array -> empty .)
    OR              reduce using rule 62 (end_array -> empty .)
    LESSTHANOREQUAL reduce using rule 62 (end_array -> empty .)
    GREATERTHANOREQUAL reduce using rule 62 (end_array -> empty .)
    ISEQUALTO       reduce using rule 62 (end_array -> empty .)
    GREATERTHAN     reduce using rule 62 (end_array -> empty .)
    LESSTHAN        reduce using rule 62 (end_array -> empty .)
    DO              reduce using rule 62 (end_array -> empty .)
    THEN            reduce using rule 62 (end_array -> empty .)
    EQUALS          reduce using rule 62 (end_array -> empty .)
    COMMA           reduce using rule 62 (end_array -> empty .)
    GOTO            reduce using rule 62 (end_array -> empty .)
    LABEL_SALTO     reduce using rule 62 (end_array -> empty .)
    FOR             reduce using rule 62 (end_array -> empty .)
    WHILE           reduce using rule 62 (end_array -> empty .)
    IF              reduce using rule 62 (end_array -> empty .)
    LET             reduce using rule 62 (end_array -> empty .)
    CALL            reduce using rule 62 (end_array -> empty .)
    INPUT           reduce using rule 62 (end_array -> empty .)
    PRINT           reduce using rule 62 (end_array -> empty .)
    END             reduce using rule 62 (end_array -> empty .)
    RETURN          reduce using rule 62 (end_array -> empty .)
    LOOP            reduce using rule 62 (end_array -> empty .)
    ELSE            reduce using rule 62 (end_array -> empty .)
    NEXT            reduce using rule 62 (end_array -> empty .)
    CLOSEPAR        reduce using rule 62 (end_array -> empty .)
    TO              reduce using rule 62 (end_array -> empty .)
    RBRACKET        reduce using rule 62 (end_array -> empty .)


state 108

    (60) repeated_size_access -> LBRACKET expression . RBRACKET repeated_size_access

    RBRACKET        shift and go to state 118


state 109

    (27) statement -> IF aux_if THEN block . ELSE aux_else block END IF aux_fin

    ELSE            shift and go to state 119


state 110

    (31) statement -> LET aux_array EQUALS expression .

    GOTO            reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    LABEL_SALTO     reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    FOR             reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    DO              reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    WHILE           reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    IF              reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    LET             reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    CALL            reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    INPUT           reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    PRINT           reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    END             reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    RETURN          reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    LOOP            reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    ELSE            reduce using rule 31 (statement -> LET aux_array EQUALS expression .)
    NEXT            reduce using rule 31 (statement -> LET aux_array EQUALS expression .)


state 111

    (39) repeated_print -> repeated_elem COMMA repeated_print .

    GOTO            reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    LABEL_SALTO     reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    FOR             reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    DO              reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    WHILE           reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    IF              reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    LET             reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    CALL            reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    INPUT           reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    PRINT           reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    END             reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    RETURN          reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    LOOP            reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    ELSE            reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)
    NEXT            reduce using rule 39 (repeated_print -> repeated_elem COMMA repeated_print .)


state 112

    (3) var -> DIM repeated_identifier AS type repeated_size aux_size . var
    (3) var -> . DIM repeated_identifier AS type repeated_size aux_size var
    (4) var -> . DIM repeated_identifier AS STRING_TYPE var
    (5) var -> . empty
    (69) empty -> .

    DIM             shift and go to state 5
    LABEL           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    var                            shift and go to state 120
    empty                          shift and go to state 6

state 113

    (8) aux_size -> empty .

    DIM             reduce using rule 8 (aux_size -> empty .)
    LABEL           reduce using rule 8 (aux_size -> empty .)
    GOTO            reduce using rule 8 (aux_size -> empty .)
    LABEL_SALTO     reduce using rule 8 (aux_size -> empty .)
    FOR             reduce using rule 8 (aux_size -> empty .)
    DO              reduce using rule 8 (aux_size -> empty .)
    WHILE           reduce using rule 8 (aux_size -> empty .)
    IF              reduce using rule 8 (aux_size -> empty .)
    LET             reduce using rule 8 (aux_size -> empty .)
    CALL            reduce using rule 8 (aux_size -> empty .)
    INPUT           reduce using rule 8 (aux_size -> empty .)
    PRINT           reduce using rule 8 (aux_size -> empty .)
    END             reduce using rule 8 (aux_size -> empty .)


state 114

    (6) repeated_size -> LBRACKET INT . RBRACKET repeated_size

    RBRACKET        shift and go to state 121


state 115

    (17) statement -> FOR aux1 TO aux2 block . NEXT aux3

    NEXT            shift and go to state 122


state 116

    (21) statement -> DO do_while_inicio block LOOP WHILE . aux_do_while
    (23) aux_do_while -> . expression
    (43) expression -> . expression_s op_rel expression_s
    (44) expression -> . expression_s
    (45) expression_s -> . term
    (46) expression_s -> . term PLUS expression_s
    (47) expression_s -> . term MINUS expression_s
    (48) expression_s -> . term OR expression_s
    (49) term -> . factor
    (50) term -> . factor MULTIPLY term
    (51) term -> . factor DIVIDE term
    (52) term -> . factor AND term
    (53) factor -> . elem
    (54) factor -> . OPENPAR expression CLOSEPAR
    (55) elem -> . INT
    (56) elem -> . aux_array
    (57) elem -> . elem_else
    (58) aux_array -> . size_identifier repeated_size_access end_array
    (63) elem_else -> . FLOAT
    (59) size_identifier -> . IDENTIFIER

    OPENPAR         shift and go to state 42
    INT             shift and go to state 43
    FLOAT           shift and go to state 47
    IDENTIFIER      shift and go to state 48

    aux_do_while                   shift and go to state 123
    expression                     shift and go to state 124
    expression_s                   shift and go to state 38
    term                           shift and go to state 39
    factor                         shift and go to state 40
    elem                           shift and go to state 41
    aux_array                      shift and go to state 44
    elem_else                      shift and go to state 45
    size_identifier                shift and go to state 46

state 117

    (24) statement -> WHILE aux_while DO block LOOP . fin_while
    (26) fin_while -> . empty
    (69) empty -> .

    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)
    RETURN          reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)
    ELSE            reduce using rule 69 (empty -> .)
    NEXT            reduce using rule 69 (empty -> .)

    fin_while                      shift and go to state 125
    empty                          shift and go to state 126

state 118

    (60) repeated_size_access -> LBRACKET expression RBRACKET . repeated_size_access
    (60) repeated_size_access -> . LBRACKET expression RBRACKET repeated_size_access
    (61) repeated_size_access -> . empty
    (69) empty -> .

    LBRACKET        shift and go to state 83
    MULTIPLY        reduce using rule 69 (empty -> .)
    DIVIDE          reduce using rule 69 (empty -> .)
    AND             reduce using rule 69 (empty -> .)
    PLUS            reduce using rule 69 (empty -> .)
    MINUS           reduce using rule 69 (empty -> .)
    OR              reduce using rule 69 (empty -> .)
    LESSTHANOREQUAL reduce using rule 69 (empty -> .)
    GREATERTHANOREQUAL reduce using rule 69 (empty -> .)
    ISEQUALTO       reduce using rule 69 (empty -> .)
    GREATERTHAN     reduce using rule 69 (empty -> .)
    LESSTHAN        reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    THEN            reduce using rule 69 (empty -> .)
    EQUALS          reduce using rule 69 (empty -> .)
    COMMA           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)
    RETURN          reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)
    ELSE            reduce using rule 69 (empty -> .)
    NEXT            reduce using rule 69 (empty -> .)
    CLOSEPAR        reduce using rule 69 (empty -> .)
    TO              reduce using rule 69 (empty -> .)
    RBRACKET        reduce using rule 69 (empty -> .)

    repeated_size_access           shift and go to state 127
    empty                          shift and go to state 84

state 119

    (27) statement -> IF aux_if THEN block ELSE . aux_else block END IF aux_fin
    (29) aux_else -> . empty
    (69) empty -> .

    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    aux_else                       shift and go to state 128
    empty                          shift and go to state 129

state 120

    (3) var -> DIM repeated_identifier AS type repeated_size aux_size var .

    LABEL           reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    GOTO            reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    LABEL_SALTO     reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    FOR             reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    DO              reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    WHILE           reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    IF              reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    LET             reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    CALL            reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    INPUT           reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    PRINT           reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)
    END             reduce using rule 3 (var -> DIM repeated_identifier AS type repeated_size aux_size var .)


state 121

    (6) repeated_size -> LBRACKET INT RBRACKET . repeated_size
    (6) repeated_size -> . LBRACKET INT RBRACKET repeated_size
    (7) repeated_size -> . empty
    (69) empty -> .

    LBRACKET        shift and go to state 90
    DIM             reduce using rule 69 (empty -> .)
    LABEL           reduce using rule 69 (empty -> .)
    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)

    repeated_size                  shift and go to state 130
    empty                          shift and go to state 91

state 122

    (17) statement -> FOR aux1 TO aux2 block NEXT . aux3
    (20) aux3 -> . IDENTIFIER

    IDENTIFIER      shift and go to state 132

    aux3                           shift and go to state 131

state 123

    (21) statement -> DO do_while_inicio block LOOP WHILE aux_do_while .

    GOTO            reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    LABEL_SALTO     reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    FOR             reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    DO              reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    WHILE           reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    IF              reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    LET             reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    CALL            reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    INPUT           reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    PRINT           reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    END             reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    RETURN          reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    LOOP            reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    ELSE            reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)
    NEXT            reduce using rule 21 (statement -> DO do_while_inicio block LOOP WHILE aux_do_while .)


state 124

    (23) aux_do_while -> expression .

    GOTO            reduce using rule 23 (aux_do_while -> expression .)
    LABEL_SALTO     reduce using rule 23 (aux_do_while -> expression .)
    FOR             reduce using rule 23 (aux_do_while -> expression .)
    DO              reduce using rule 23 (aux_do_while -> expression .)
    WHILE           reduce using rule 23 (aux_do_while -> expression .)
    IF              reduce using rule 23 (aux_do_while -> expression .)
    LET             reduce using rule 23 (aux_do_while -> expression .)
    CALL            reduce using rule 23 (aux_do_while -> expression .)
    INPUT           reduce using rule 23 (aux_do_while -> expression .)
    PRINT           reduce using rule 23 (aux_do_while -> expression .)
    END             reduce using rule 23 (aux_do_while -> expression .)
    RETURN          reduce using rule 23 (aux_do_while -> expression .)
    LOOP            reduce using rule 23 (aux_do_while -> expression .)
    ELSE            reduce using rule 23 (aux_do_while -> expression .)
    NEXT            reduce using rule 23 (aux_do_while -> expression .)


state 125

    (24) statement -> WHILE aux_while DO block LOOP fin_while .

    GOTO            reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    LABEL_SALTO     reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    FOR             reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    DO              reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    WHILE           reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    IF              reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    LET             reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    CALL            reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    INPUT           reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    PRINT           reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    END             reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    RETURN          reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    LOOP            reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    ELSE            reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)
    NEXT            reduce using rule 24 (statement -> WHILE aux_while DO block LOOP fin_while .)


state 126

    (26) fin_while -> empty .

    GOTO            reduce using rule 26 (fin_while -> empty .)
    LABEL_SALTO     reduce using rule 26 (fin_while -> empty .)
    FOR             reduce using rule 26 (fin_while -> empty .)
    DO              reduce using rule 26 (fin_while -> empty .)
    WHILE           reduce using rule 26 (fin_while -> empty .)
    IF              reduce using rule 26 (fin_while -> empty .)
    LET             reduce using rule 26 (fin_while -> empty .)
    CALL            reduce using rule 26 (fin_while -> empty .)
    INPUT           reduce using rule 26 (fin_while -> empty .)
    PRINT           reduce using rule 26 (fin_while -> empty .)
    END             reduce using rule 26 (fin_while -> empty .)
    RETURN          reduce using rule 26 (fin_while -> empty .)
    LOOP            reduce using rule 26 (fin_while -> empty .)
    ELSE            reduce using rule 26 (fin_while -> empty .)
    NEXT            reduce using rule 26 (fin_while -> empty .)


state 127

    (60) repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .

    MULTIPLY        reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    DIVIDE          reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    AND             reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    PLUS            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    MINUS           reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    OR              reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    LESSTHANOREQUAL reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    GREATERTHANOREQUAL reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    ISEQUALTO       reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    GREATERTHAN     reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    LESSTHAN        reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    DO              reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    THEN            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    EQUALS          reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    COMMA           reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    GOTO            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    LABEL_SALTO     reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    FOR             reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    WHILE           reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    IF              reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    LET             reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    CALL            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    INPUT           reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    PRINT           reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    END             reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    RETURN          reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    LOOP            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    ELSE            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    NEXT            reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    CLOSEPAR        reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    TO              reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)
    RBRACKET        reduce using rule 60 (repeated_size_access -> LBRACKET expression RBRACKET repeated_size_access .)


state 128

    (27) statement -> IF aux_if THEN block ELSE aux_else . block END IF aux_fin
    (13) block -> . statement block
    (14) block -> . empty
    (15) statement -> . GOTO LABEL
    (16) statement -> . LABEL_SALTO
    (17) statement -> . FOR aux1 TO aux2 block NEXT aux3
    (21) statement -> . DO do_while_inicio block LOOP WHILE aux_do_while
    (24) statement -> . WHILE aux_while DO block LOOP fin_while
    (27) statement -> . IF aux_if THEN block ELSE aux_else block END IF aux_fin
    (31) statement -> . LET aux_array EQUALS expression
    (32) statement -> . CALL LABEL
    (37) statement -> . INPUT repeated_print
    (38) statement -> . PRINT repeated_print
    (69) empty -> .

    GOTO            shift and go to state 16
    LABEL_SALTO     shift and go to state 17
    FOR             shift and go to state 18
    DO              shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    LET             shift and go to state 22
    CALL            shift and go to state 23
    INPUT           shift and go to state 24
    PRINT           shift and go to state 25
    END             reduce using rule 69 (empty -> .)

    block                          shift and go to state 133
    statement                      shift and go to state 14
    empty                          shift and go to state 15

state 129

    (29) aux_else -> empty .

    GOTO            reduce using rule 29 (aux_else -> empty .)
    LABEL_SALTO     reduce using rule 29 (aux_else -> empty .)
    FOR             reduce using rule 29 (aux_else -> empty .)
    DO              reduce using rule 29 (aux_else -> empty .)
    WHILE           reduce using rule 29 (aux_else -> empty .)
    IF              reduce using rule 29 (aux_else -> empty .)
    LET             reduce using rule 29 (aux_else -> empty .)
    CALL            reduce using rule 29 (aux_else -> empty .)
    INPUT           reduce using rule 29 (aux_else -> empty .)
    PRINT           reduce using rule 29 (aux_else -> empty .)
    END             reduce using rule 29 (aux_else -> empty .)


state 130

    (6) repeated_size -> LBRACKET INT RBRACKET repeated_size .

    DIM             reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    LABEL           reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    GOTO            reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    LABEL_SALTO     reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    FOR             reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    DO              reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    WHILE           reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    IF              reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    LET             reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    CALL            reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    INPUT           reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    PRINT           reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)
    END             reduce using rule 6 (repeated_size -> LBRACKET INT RBRACKET repeated_size .)


state 131

    (17) statement -> FOR aux1 TO aux2 block NEXT aux3 .

    GOTO            reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    LABEL_SALTO     reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    FOR             reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    DO              reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    WHILE           reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    IF              reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    LET             reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    CALL            reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    INPUT           reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    PRINT           reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    END             reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    RETURN          reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    LOOP            reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    ELSE            reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)
    NEXT            reduce using rule 17 (statement -> FOR aux1 TO aux2 block NEXT aux3 .)


state 132

    (20) aux3 -> IDENTIFIER .

    GOTO            reduce using rule 20 (aux3 -> IDENTIFIER .)
    LABEL_SALTO     reduce using rule 20 (aux3 -> IDENTIFIER .)
    FOR             reduce using rule 20 (aux3 -> IDENTIFIER .)
    DO              reduce using rule 20 (aux3 -> IDENTIFIER .)
    WHILE           reduce using rule 20 (aux3 -> IDENTIFIER .)
    IF              reduce using rule 20 (aux3 -> IDENTIFIER .)
    LET             reduce using rule 20 (aux3 -> IDENTIFIER .)
    CALL            reduce using rule 20 (aux3 -> IDENTIFIER .)
    INPUT           reduce using rule 20 (aux3 -> IDENTIFIER .)
    PRINT           reduce using rule 20 (aux3 -> IDENTIFIER .)
    END             reduce using rule 20 (aux3 -> IDENTIFIER .)
    RETURN          reduce using rule 20 (aux3 -> IDENTIFIER .)
    LOOP            reduce using rule 20 (aux3 -> IDENTIFIER .)
    ELSE            reduce using rule 20 (aux3 -> IDENTIFIER .)
    NEXT            reduce using rule 20 (aux3 -> IDENTIFIER .)


state 133

    (27) statement -> IF aux_if THEN block ELSE aux_else block . END IF aux_fin

    END             shift and go to state 134


state 134

    (27) statement -> IF aux_if THEN block ELSE aux_else block END . IF aux_fin

    IF              shift and go to state 135


state 135

    (27) statement -> IF aux_if THEN block ELSE aux_else block END IF . aux_fin
    (30) aux_fin -> . empty
    (69) empty -> .

    GOTO            reduce using rule 69 (empty -> .)
    LABEL_SALTO     reduce using rule 69 (empty -> .)
    FOR             reduce using rule 69 (empty -> .)
    DO              reduce using rule 69 (empty -> .)
    WHILE           reduce using rule 69 (empty -> .)
    IF              reduce using rule 69 (empty -> .)
    LET             reduce using rule 69 (empty -> .)
    CALL            reduce using rule 69 (empty -> .)
    INPUT           reduce using rule 69 (empty -> .)
    PRINT           reduce using rule 69 (empty -> .)
    END             reduce using rule 69 (empty -> .)
    RETURN          reduce using rule 69 (empty -> .)
    LOOP            reduce using rule 69 (empty -> .)
    ELSE            reduce using rule 69 (empty -> .)
    NEXT            reduce using rule 69 (empty -> .)

    aux_fin                        shift and go to state 136
    empty                          shift and go to state 137

state 136

    (27) statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .

    GOTO            reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    LABEL_SALTO     reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    FOR             reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    DO              reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    WHILE           reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    IF              reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    LET             reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    CALL            reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    INPUT           reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    PRINT           reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    END             reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    RETURN          reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    LOOP            reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    ELSE            reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)
    NEXT            reduce using rule 27 (statement -> IF aux_if THEN block ELSE aux_else block END IF aux_fin .)


state 137

    (30) aux_fin -> empty .

    GOTO            reduce using rule 30 (aux_fin -> empty .)
    LABEL_SALTO     reduce using rule 30 (aux_fin -> empty .)
    FOR             reduce using rule 30 (aux_fin -> empty .)
    DO              reduce using rule 30 (aux_fin -> empty .)
    WHILE           reduce using rule 30 (aux_fin -> empty .)
    IF              reduce using rule 30 (aux_fin -> empty .)
    LET             reduce using rule 30 (aux_fin -> empty .)
    CALL            reduce using rule 30 (aux_fin -> empty .)
    INPUT           reduce using rule 30 (aux_fin -> empty .)
    PRINT           reduce using rule 30 (aux_fin -> empty .)
    END             reduce using rule 30 (aux_fin -> empty .)
    RETURN          reduce using rule 30 (aux_fin -> empty .)
    LOOP            reduce using rule 30 (aux_fin -> empty .)
    ELSE            reduce using rule 30 (aux_fin -> empty .)
    NEXT            reduce using rule 30 (aux_fin -> empty .)

